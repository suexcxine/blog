title: <<The Linux Command Line>> 第十一章笔记 进程
date: 2015-09-07 20:00:11
tags: [linux, bash]
---
进程是怎样工作的

当系统启动的时候，内核先把一些它自己的程序初始化为进程，然后运行一个叫做 init 的程序。
init， 依次地，再运行一系列的称为 init 脚本的 shell 脚本（位于/etc），它们可以启动所有的系统服务。

## ps命令

字段含义
* TIME 字段表示 进程所消耗的 CPU 时间数量。
* TTY ?表示没有终端
* USER     用户 ID. 进程的所有者。
* %CPU     以百分比表示的 CPU 使用率
* %MEM     以百分比表示的内存使用率
* VSZ     虚拟内存大小
* RSS     进程占用的物理内存的大小，以千字节为单位。
* START     进程运行的起始时间。若超过24小时，则用天表示。

进程状态
* R     运行。这意味着，进程正在运行或准备运行。
* S     正在睡眠。 进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络数据包。
* D     不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。
* T     已停止. 已经指示进程停止运行。稍后介绍更多。
* Z     一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除）
* <     一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。
* N     低优先级进程。 一个低优先级进程（一个“好”进程）只有当其它高优先级进程执行之后，才会得到处理器时间。

## 用top命令动态查看进程
top 命令信息字段
**load average:**     加载平均值是指，等待运行的进程数目，也就是说，处于运行状态的进程个数， 这些进程共享 CPU。展示了三个数值，每个数值对应不同的时间周期。第一个是最后60秒的平均值， 下一个是前5分钟的平均值，最后一个是前15分钟的平均值。若平均值低于1.0，则指示计算机 工作不忙碌。
**Tasks:**     总结了进程数目和各种进程状态。
**Cpu(s):**     这一行描述了 CPU 正在执行的进程的特性。
                  0.7%us     0.7% of the CPU is being used for user processes. 这意味着进程在内核之外。
                  1.0%sy     1.0%的 CPU 时间被用于系统（内核）进程。
                  0.0%ni     0.0%的 CPU 时间被用于"nice"（低优先级）进程。
                  98.3%id     98.3%的 CPU 时间是空闲的。
                  0.0%wa     0.0%的 CPU 时间来等待 I/O。
                  0.1% hi 硬中断（Hardware IRQ）占用CPU的百分比
                  0.0% si 软中断（Software Interrupts）占用CPU的百分比
                  0.0% st 虚拟机偷取时间,是专门对虚拟机来说的，一台物理是可以虚拟化出几台虚拟机的。在其中一台虚拟机上用top查看发现st不为0，就说明本来有这么多个cpu时间是安排给我这个虚拟机的，但是由于某种虚拟技术，把这个cpu时间分配给了其他的虚拟机了。这就叫做偷取。
**Mem:**     展示物理内存的使用情况。
**Swap:**     展示交换分区（虚拟内存）的使用情况。

h 帮助
q 退出

## jobs
&可以在后台执行

## fg %1
## bg %1

## kill
常用信号
* 1     HUP     挂起。这是美好往昔的痕迹，那时候终端机通过电话线和调制解调器连接到 远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂起”。 通过关闭一个终端会话，可以说明这个信号的作用。发送这个信号到终端机上的前台程序，程序会终止。
* 许多守护进程也使用这个信号，来重新初始化。这意味着，当发送这个信号到一个守护进程后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。
* 2     INT     中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。
* 9     KILL     杀死。这个信号很特别。鉴于进程可能会选择不同的方式，来处理发送给它的 信号，其中也包含忽略信号，这样呢，从不发送 Kill 信号到目标进程。而是内核立即终止 这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存劳动成果。 因为这个原因，把 KILL 信号看作杀手锏，当其它终止信号失败后，再使用它。
* 15     TERM     终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么 这个信号终止。
* 18     CONT     继续。在停止一段时间后，进程恢复运行。
* 19     STOP     停止。这个信号导致进程停止运行，而没有终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。
* 3     QUIT     退出
* 11     SEGV     段错误。如果一个程序非法使用内存，就会发送这个信号。也就是说， 程序试图写入内存，而这个内存空间是不允许此程序写入的。
* 20     TSTP     终端停止。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。
* 28     WINCH     改变窗口大小。当改变窗口大小时，系统会发送这个信号。 一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。

kill -l 可以得到一个完整的信号列表

## killall
给多个进程发送信号
也有可能通过 killall 命令，给匹配特定程序或用户名的多个进程发送信号。

## 其它与进程相关的命令
pstree     输出一个树型结构的进程列表，这个列表展示了进程间父/子关系。
vmstat     输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O。 为了看到连续的显示结果，则在命令名后加上延时的时间（以秒为单位）。例如，“vmstat 5”。 终止输出，按下 Ctrl-c 组合键。
xload      一个图形界面程序，可以画出系统负载的图形。
tload      与 xload 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。

