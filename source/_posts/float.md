title: 浮点数
date: 2016-08-21 16:34:00
tags: [cs]
---

传说中邪恶的IEEE 754和著名的0.1 + 0.2 = 0.30000000000000004

<!--more-->

与定点数不同,浮点数面临的情形更复杂
有0.0000000000000000000000001这样的, 也有10000000000000000000000000.0这样的
取值范围广, 但是计算机资源有限, 想要省怎么办? 于是科学计数法上场
上面两种情况用科学计数法分别为1.0e-25和1.0e25
保存指数部分的25即可表示那么大的数和那么小的数

32位(单精度)浮点数由1位符号位S, 8位指数位E和23位有效数字M组成
64位(双精度)浮点数由1位符号位S,11位指数位E和52位有效数字M组成

0.1 + 0.2 = 0.30000000000000004是因为误差积累,
由于二进制无法精确表示1/5, 所以0.1和0.2都无法精确表示, 用了一个最接近的近似表示,
加起来之后误差积累, 超过了可以忽略的误差, 就变成0.30000000000000004了
想要避免这类误差问题可以使用decimal floating point, 或者fixed-point,
https://en.wikipedia.org/wiki/Decimal_floating_point

## 特殊规定

有效数字M的取值范围是1≤M<2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。
IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。
比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。
这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。

指数E为一个无符号整数（unsigned int）。这意味着，
如果E为8位，它的取值范围为0~255； 如果E为11位，它的取值范围为0~2047。
但是，我们知道，科学计数法中的E是可以出现负数的，
所以IEEE 754规定，E的真实值必须再减去一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。
比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。
然后，指数E还可以再分成三种情况：

* E不全为0且不全为1
这时浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。
* E全为0
这时浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。
* E全为1
这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。

## 参考链接
http://0.30000000000000004.com/
http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html

