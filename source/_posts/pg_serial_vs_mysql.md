title: PostgreSQL与MySQL中手动插入记录对序列和自增值的影响
date: 2024-02-26

tags: [db, postgres, mysql]
---

postgres 的表自己指定了 id 写了一行的话，之后再用自增的 id 会出主键重复。。需要手动维护一下 serial 才能好。。这背后有哪些东西呢

<!--more-->

在使用PostgreSQL或MySQL等关系数据库时，自增列（或序列）是处理自动生成唯一标识符的常见机制。尽管这两个系统在功能上相似，它们在细节处理上存在差异，尤其是在手动插入记录时对序列或自增值的影响。

#### 1. 手动插入时可能导致的问题

在PostgreSQL中，如果手动向表中插入一条记录，并指定了一个大于当前序列值的ID，那么序列不会自动更新。这可能导致后续的插入操作因尝试使用一个已存在的ID而失败，造成主键冲突。

#### 2. 如何解决

解决这个问题的方法是手动更新序列的值。在PostgreSQL中，可以使用`setval`函数调整序列值，确保它高于表中当前最大的ID值。例如：

```sql
SELECT setval('序列名称', (SELECT MAX(主键列) FROM 表名称));
```

序列名称一般是 `yourtablename_id_seq`
这个操作确保了序列值的正确性，避免了未来插入操作的冲突。


#### 3. 为什么会有这个问题

这个问题的根源在于PostgreSQL的序列设计。序列在PostgreSQL中是独立的对象，旨在提供一个可预测的数字生成器，而不是自动适应表中数据的变化。这种设计提供了更高的灵活性和控制，但也要求开发者在特定情况下手动管理序列值。

#### 4. 为什么MySQL没有这个问题

与PostgreSQL不同，MySQL的自增值直接与表相关联，且自增机制假定其主要用途是作为唯一标识符。当手动插入一个大于当前自增值的ID时，MySQL会自动调整内部的自增计数器，保证下一个自动生成的值不会与已存在的值冲突。这种设计简化了自增列的管理，但牺牲了一定的灵活性。

#### 5. PostgreSQL在这方面的优势

尽管需要手动管理序列可能看起来是一个缺点，但PostgreSQL序列的设计提供了几个优势：

- **灵活性和控制**：序列的独立性允许它们被多个表共享，也支持非主键列的使用场景。
- **精确性**：手动管理序列可以避免意外的序列值跳跃，特别是在复杂的数据操作场景中。
- **广泛应用**：独立的序列支持更广泛的用途，包括非自增的唯一值生成等。
- **减少开销**：PostgreSQL的序列是独立于表的对象，这意味着在插入操作时，数据库不需要额外检查当前插入的值是否超过了序列的当前值，从而减少了每次插入操作的开销。相比之下，自动更新序列或自增值的数据库系统（如MySQL在手动插入较大值时）可能需要执行这样的检查，以确保自增计数器的值是最新的，这在高并发场景下可能引入额外的性能开销。
- **避免锁竞争**：由于PostgreSQL的序列操作和表数据插入是分离的，序列的更新（即使是手动的）可以独立于表数据的插入操作进行，减少了在处理大量并发插入时可能出现的锁竞争。
- **更好的并发处理**：PostgreSQL通过其MVCC（多版本并发控制）机制有效地处理并发操作，序列的独立性进一步支持了这种并发处理能力，因为序列值的生成不会直接阻塞表中的其他操作。

